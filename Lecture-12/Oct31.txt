   -------------------------------------------------
   |     CS 35L SOFTWARE CONSTRUCTION LAB          |
   |      Stack Frame and Buffer Overflow          |
   |            November 7, 2011                   |
   -------------------------------------------------

=== AGENDA ===========================================

  1 Process Memory Region
  2 Stack Frame

======================================================


=== PROCESS MEMORY REGION ============================

               /------------------\  lower
Code           |                  |  memory
Read-only data |       Text       |  addresses
               |                  |
               |------------------|
static vars    |   (Initialized)  |
               |        Data      |
               |  (Uninitialized) |
               |------------------|
               |                  |
               |       Stack      |  higher
               |                  |  memory
               \------------------/  addresses

           Fig. 1 Process Memory Regions


  -- What's a Stack? --
    Stack - LIFO data structure
    High level programs are built upon the concept of
  stack.
    * Procedure Calls
    * Dynamically allocate local variables
    * Pass parameters
    * Return values

  -- The Stack Region --
    * Contiguous block of memory containing data
    * The stack pointer (SP) points to top of stack
    * Bottom of stack is at a fixed address
    * Size is dynamically adjusted by the kernel
    * CPU implements PUSH/POP instructions

======================================================


=== STACK FRAMES =====================================

  -- Stack Frame --
    * A logical frame of data
    * Pushed/Popped when calling/returning a function
    * Parameters, local vars, data necessary to recover
      previous stack frame

  -- Frame Pointer (FP) --
    FP points to fixed location within a frame and
  varaibles are referenced by offset to the FP.
    When a procedure call happens, FP is stored.

  -- example1.c --

  void function(int a, int b, int c) {
    int buffer1[2];
    int buffer2[4];
    buffer1[0] = 0;
    buffer1[1] = a;
    buffer2[0] = b;
    buffer2[3] = c;
  }

  void main() {
    function(1,2,3);
  }

  -- Compile the code into assmeblers --
  gcc -fno-stack-protector -S -o example1.s example1.c

  -- Essential of assembler code --

    ~~ Inside main() ~~
    pushl   %ebp
    movl    %esp, %ebp
    subl    $12, %esp
    movl    $3, 8(%esp)
    movl    $2, 4(%esp)
    movl    $1, (%esp)
    call    function

    ~~ Inside function() ~~
    pushl   %ebp
    movl    %esp, %ebp
    subl    $32, %esp
    movl    $0, -8(%ebp)
    movl    8(%ebp), %eax
    movl    %eax, -4(%ebp)
    movl    12(%ebp), %eax
    movl    %eax, -24(%ebp)
    movl    16(%ebp), %eax
    movl    %eax, -12(%ebp)
    leave

    ~~ Instructions ~~
    pushl - push a value into stack
    movl - move data from one reg/mem to another
    subl - substract the value
    call - call function
    leave - leave the function

    ~~ Registers ~~
    %rsp: stack pointer
    %rbp: frame pointer
    %eax: general data registers


  -- Stack status when "function" is called --
  [ buffer2 ] [ buffer1 ] [fp(main)] [ret] [a] [b] [c]


======================================================


=== BUFFER OVERFLOW ==================================

  A buffer overflow is the result of stuffing more data
into a buffer than it can handle.

  -- example2.c --



======================================================

